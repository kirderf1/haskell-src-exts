{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE UndecidableInstances #-}
module MaybeE where
import qualified Data.Comp
import qualified Data.Comp.Derive
import qualified Data.Comp.Show ()
import qualified Data.Comp.Equality ()

data B composable_types_recursive_var = B Int
                                          deriving Functor

composable_types_constructor_B ::
                                 B Data.Comp.:<: g => Int -> Data.Comp.Term g
composable_types_constructor_B arg_1 = Data.Comp.inject (B arg_1)

data C composable_types_recursive_var = C deriving Functor

composable_types_constructor_C ::
                                 C Data.Comp.:<: g => Data.Comp.Term g
composable_types_constructor_C = Data.Comp.inject C

data D composable_types_recursive_var = D composable_types_recursive_var
                                          deriving Functor

composable_types_constructor_D ::
                                 D Data.Comp.:<: g => Data.Comp.Term g -> Data.Comp.Term g
composable_types_constructor_D arg_1 = Data.Comp.inject (D arg_1)

e ::
  Int -> Maybe (Data.Comp.Term (B Data.Comp.:+: C Data.Comp.:+: D))
e = undefined
