{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE UndecidableInstances #-}
module PatternMatching2 where
import qualified Data.Comp
import qualified Data.Comp.Derive
import qualified Data.Comp.Show ()
import qualified Data.Comp.Equality ()

data B composable_types_recursive_var = B Int

composable_types_constructor_B ::
                                 B Data.Comp.:<: g => Int -> Data.Comp.Term g
composable_types_constructor_B arg_1 = Data.Comp.inject (B arg_1)

data C composable_types_recursive_var = C

composable_types_constructor_C ::
                                 C Data.Comp.:<: g => Data.Comp.Term g
composable_types_constructor_C = Data.Comp.inject C

d :: Data.Comp.Term (B) -> Int
d a
  = case a of
        (Term (B i)) -> i

e :: Data.Comp.Term (B Data.Comp.:+: C) -> Int
e a
  = case a of
        (Term (Inl (B i))) -> i
        (Term (Inr C)) -> 0
